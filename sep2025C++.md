# C++
 
Consider using the `print` library instead of standard formatting to make prettier formatting.
Requires C++23 to be included in the new compiler.
Also consider using `cstdio` and puts which has far simpler assembly.
 
3 Ts:
 
- Testing - Understand what the code does
- Tools - Make it necessary to find errors before deployment, make sure that the linter validates the typeinting
- Technique - Makes the first 2 things easier
 
"Make your API hard to use wrong"
 
C++ is an ISO standard which specifies what the compiler is doing.
That standard shows explicit object lifetime that we can count on, most other languages do not have this.
 
Book - "Programming Puzzles Big Book" by Jason Turner
 
Never declare a variable until you have a use for it.
 
## Deeper things
 
### Random
 
Lambdas require a trailing return type in the new C++ standard.
 
`inline` will make copies of the data for each thing that uses it, which could make the memory footprint blow up.
 
`__` is reserved in C++
 
If undefined behavior is invoked, the compiler can do what it wants with the code.
Signed integer overflow will generate an overflow.
Unsigned integer overflow is defined in C++ (C++23 and onward uses 2's compliment).
 
Often converting/casting between libraries will result in undefined behavior.
 
Unused static variables could impact the assembly and therefore the running of the code.
 
Null Pointers are undefined and will issue warnings in modern compilers.
 
Use `{}` to not allow narrow conversions.
 
Base classes are initialized in order of declaration.
 
Use `override` as a safeguard when overriding an inherited function
 
staic variables are always initialized.
Non-static variables are not always initialized, it could result in undefined behavior.
All primitive types are uninitialized by default.
 
`streamable` things are things that can be sent to `cout`
 
Some constructors look like assignments but are actually constructors, for example the vector array constructor.
 
Study lambdas, everything is implemented in them so if you understand them you will understand the whole language.
 
### Best Practice
 
- Use at most one of `final`, `virtual`, or `override`
- Consider enabling the auto initializing of variables in the compiler to ensure that all non-static variables are initialized
- Avoid 2 phase constructions - put everything in the constructor
- Rely on the compiler to perform Return Value Optimization, this will reduce the binary size and make the code more efficient. Modern compilers will give warnings if this is not done appropriately in the code
- Do your best to process data linearly
- Prefer using `const auto`. Especially in for loops
- Compose using functions wherever possible
- Don't pass shared pointers unless you need to participate in the lifetime of the shared object
- Don't modify the underlying thing from a view
- Don't pass smart pointers unless you need to convey ownership
- Don't pass any primitive type by reference
 
### First Code Review (slide 5.7)
 
`std::move` is saying that "I am done with this variable", use for overload resolution.
It will do a cast to an r value reference.
It will set the variable on the stack that it moves from to a null pointer and take over the pointer to what is on the heap.
The original variable is still around until it goes out of scope and its destructor will be called.
It's constructor will require a `&&` (copy constructor uses `&`).
It will not work on a variable that is `const` because const makes it so that the original variable cannot be changed and its pointer cannot be changed to null pointer.
If you try to move a const, it will likely copy instead of move.
In general try to avoid using `move`, it is often a smell.
If you provide your own destructor you don't get move operations because it is hard to call the right constructor since it will leave the original variable behind and its reference doesn't exist anymore.
 
Be careful about pointers, what they are pointing to can go out of scope and cannot reference what it is pointing to.
It can hide a lot of bugs because that memory segment may not have been overwritten and will still return the expected values.
This makes it in an undefined state.
Often, we should avoid using pointers in modern C++.
 
Mutable globals are bad but compile time globals are acceptable.
 
Do not rely on floating comparisons.
 
### Autos And Other Things
 
`auto` only works for things in the built in types when not used with a return type.
To use a return type use the trailing return `auto func_name() -> type`.
It can cocoerse to a common type but it can be a problem when having different types within the function from if statements or other things.
The return types for auto should be the same for each condition (if there is a case or if, it should always return the same type).
 
You may not be able to specify the return type of things, so it should be `auto` in that case.
Be careful with implicit conversions when doing auto.
That cane be specified with a curly brace, and is sometimes required by the compiler.
 
`consteval` must be evaluated at compile time, which is a good default for functions that have no inputs.
You will know your parameters at compile time.
Only functions can be `consteval`.
 
`constexpr` tells the compiler that this can happen at compile time.
a concatenation of constant and expression.
This forces things to be evaluated at compile time.
Leaks and variables must be valid at compile time which helps to write more secure code.
Test these things during compilation!
 
`[[nodiscard]]` gives a warning if the function is called and the return type is not used.
It should be used for any getter.
It also helps with implementing fewer side effects.
A notification will be made when the compiler is run so it should be fixed.
*Use this liberally*.
 
`noexcept` - tomorrow
 
Adding `()` to a lambda line will evaluate the lambda, otherwise it will return a function from the lambda.
Lambda does not have a return type because it returns a function, so it if making a factory an auto type will be needed.
Lambdas return a pointer to a function and is implicitly convertible to a boolean.
It is actually a closure object around a struct that can have all of those attributes a normal closure would have.
`[]` is called a lambda introducer.
Lambdas can be named and it might be worth naming them to improve readability.
 
Do not try to reference a function with a `&` because you don't know what the type is.
If you are given a pointer to a function, `&` is acceptable.
 
Slicing is a partial copy of an object, it is often considered an anti-pattern.
Slicing is done by taking a reference to an object and only use certain pieces, thereby slicing off the things that are not used.
 
Template types must be known at compile time because the size of the object needs to be known at compile time.
templates are not functions, they are closer to being a placeholder.
 
`mutable` allows you to override your own operators.
VERY bad in global.
 
`concept` is asking a question at compile time about the types or things that the compiler knows about.
 
String; to make a string you will need a pointer to the start (64bit), either a pointer to the end or a length (64 bit), and a capacity (64 bit) making for 24 bytes available.
Capacity is for growing, how much extra space you have in the memory location.
If you have a small string that can fit in the 24 bytes, there is no heap allocation to point to the data, everything works on the stack.
This means that move doesn't behave as expected, it might actually copy.
But a move from string is generally not allowed.
 
Rule of zero - Don't define any special member functions if you don't have to (eg constructors, destructors, etc).
 
Compiling with `-Wall` is not all of the warnings, it only has the warnings from older compilers from like 98.
Also, use `Wextra` and `Wshadow` to check other warnings and shadowing variables.
Use `Weverything` sparingly as it will tell you things that you cannot control like having extra space allocated in a struct.
 
To be polymorphic in C++ it must have a btable, virtual functions will add that and it can become polymorphic.
It is a very specific thing in C++ and it is a property of an object.
 
LTO uses an Intermediate Representation for linking instead of object files.
This allows the optimizer to see what is in each file and potentially in-line things.
Try building with LTO to catch more compile time bugs, but it does not need to be deployed but it could increase performance.
Since it does in-lining, it might make the binary bigger and will take longer to compile, but is likely to be more efficient because of the folding within the in-lining.
Consider using `-fvisability=hidden` to hide symbols that can increase optimization opportunities, it means that you have to export your symbols, and will likely lead to a 10% increase in performance.
 
`std::unreachable` invokes undefined behavior so it can be caught if it is executed.
 
Enums can take things that are not part of their enums, consider making enum struct instead so it enforces types.
 
"Spaceship Operator" is for three way comparison operators.
The contained thing needs to be three way comparable.
It is compared with the `operator<=>`.
It can do a member-wise comparison to everything in an array in order of declaration.
It can run three different operations but should probably prefer `strong_ordering`.
Do not mutate data when implementing your own operator.
 
`std::views` - part of the ranges library, cannot be reused safely and don't modify the underlying object.
It is a const pointer pointing to a non-const object.
The pointer can be re assigned causing problems.
Do not reuse views, they are lazy evaluated but they can cache state which can cause all kinds of problems.
 
Always assume a passed pointer could be null.
Reference it to make sure that it exists.
Passing a pointer could extend the lifetime of an object so that could be a reason to send a pointer.
 
If it is a view like thing or small copy it, everything else pass by reference
 
## Things to Look Up Later
 
- r value
- stack vs heap
- reflection in C++
- `git bisect`
- LTO (Link Time Optimization)
- spaceship operator
- `std::views` - part of the ranges library
- spans
